#Python基础
————————————————————————————————————————————————————————————————————————————————————————
##Python 如何执行 .py 文件？
1、在 cmd/shell 中输入命令 python a.py

2、在解释器中，通过函数 execfile("a.py")

3、在解释器中，直接输入程序语句立即执行
***
##Python 如何退出解释器？

1、 import sys
    sys.exit()
   
2、通过引发异常：raise SystemExit

3、输入EOF字符，windows下是Ctrl+Z，unix下是Ctrl+D

***
##Python 数据类型
在 python 中有4种类型的数 －** 整数，长整数，浮点数 和 复数**

***

##Python 之函数：def  foo(p1，p2，....)：

1、Python 函数定义不需要头文件

2、Python 函数定义不需要指定返回值的类型，你要麽 return value，要麽让函数自己 return None Python的NULL值）

3、Python 中变量和函数参数都不需要指明类型，根据它们得到的值，Python 会自己维护它们的类型

4、Python 语言没有子程序或过程（VB 中的 sub），统统的一切都只是函数

5、文档字符串 “““docstring””” 必须在函数的第一个逻辑行被定义，文档字符串同样也适用于模块和类

6、调用函数时，可以通过形参位置和形参名称两种方法来给函数传递实参

7、pass 语句在 pyhon 中表示一个空的语句块

8、调用函数时会为局部变量引入一个新的符号表。所有的局部变量都存储在这个局部符号表中。

9、引用参数时，会先从局部符号表中查找，然后是全局符号表，然后是内置命名表。

10、用户定义的函数名也是一个解释器认可的类型值。这个值可以赋给其它变量，使其能做为一个函数来使用
***
##Python 中lambda 函数
本质上 lambda 可以有任意数目的参数，冒号后面仅跟单个表达式作为函数体

定义：foo = lambda x：expression 相当于 def  foo（x）：expression

调用：foo（y）或直接（lambda x：expression）（y），x 形参，y 实参 

1、lambda 函数不能包含任何命令，而且只能包含一句表达式

2、lambda 并没有必须要使用它的理由，使用它仅是一种风格
***
##Python 模块
1、导入模块名用 import module_name; 导入模块中的一个子项目用 from module_name import xxx

2、访问模块内部的函数，类以及各种属性

3、要导入的模块应该被放置和调用它的程序相同的目录中，或者在 sys.path 变量所列目录之一

4、当你要导入一个模块时， Python 会依次在这些目录里寻找与你要导入的模块名称一致的 py 文件

5、并不是所有的模块都是以 py 文件存在的，比如内置模块，它们的 py 源代码并不可见，因为它们不是用 python 写成的

6、每个模块都有__name__ 属性，当模块是被导入使用时，它的值为模块名；而当模块是被直接运行时，它便是__main__
***

##Python  对象
1、字符串是对象，链表是对象，函数是对象，模块也是对象

2、Python 中对象的定义较宽松，即只要能赋予变量，或作为参数传递给函数的都能被视为对象

3、当你将一个对象赋予一个变量的时候，这个变量仅仅是这个对象的参考，也就是说，变量名指向存储这个对象的内存

：  所以当你把 a 链表赋给 b 链表的时候，你只是创建了另一个索引，而对其中任何一个的更改都会影响到另一个

：  如果你不想冒此风险，就必须通过切片 b ＝a[：]来完全复制一个链表再赋给 b，这样对 a 的更改就不会影响到 b
***

Python中每个语句以换行结束，若要在一行中写多个语句，这时语句之间必须使用用分号分隔

Python语言使用缩进块来表示程序逻辑（其它大多数语言使用大括号等）

Python并未指定缩进的空白数目，唯一的要求是同一层次的语句必须有相同的缩进空白

（注意，要么都是空格，要是么都制表符，千万别混用）
***

##Python 控制结构

－其中，1、2、3 语句后都需要带冒号：

1、if		语法为 if    elif    else

2、for		对于任何序列都适用，逐一使用序列中的每个子项目

3、while  

4、break	与C中的作用相同，用于跳出最近的一级 for 或 while 循环

5、range()	生成一个等差级数链表

6、continue	与C中的作用相同，用于继续执行下一次迭代

6、else 子句	在循环结束后（for）或条件为False（while）时执行，但循环被break中止的情况下不会执行   
              
7、pass 语句 	pass 语句什么也不做，它用于那些语法上必须要有什么语句，但程序上什么也不要做的场合
***

#Python 数据结构
——————————————————————————————————————————————————————————————————————————————————————————
##Python 字典
无序集合，所以无法像链表那样，根据 排列序号 来索引元素或索引切片

创建：dict = {1：35，2："nice"，"key"："ugly"}

索引：dict [1]             #35 was acquired

修改：dict [1] = 36    #35 replaced by 36

添加：dict [3] = 47    #pair （3：47） was added

删除：del dict[1]       #pair （1：35） was deleted

0、你只能使用不可变的对象（比如字符串）来作为字典的键

1、记住字典中的键/值对是没有顺序的。如果你想要一个特定的顺序，那么你应该在使用前自己对它们排序。

2、you can get values by key, but you can't get keys by value

4、字典中不能含有重复的键，对一个已存在的键赋值，只是简单地将原来的值替换

5、任何时候，你都可以向字典添加新的 key-value 对，但新添加值的出现位置是随机的

6、字典的元素之间没有顺序的概念，它们之间的排列完全是无序状态

7、字典的键是有大小写之分的，更重要的是字典的键是 immutable 的，所以它只能使用同样是 immutable 的类型

8、键的数据类型可以为字符串型，整型，tuple，list不行；而值可以是任何数据类型，包括字符串，整数，对象，甚至字典

9、字典的元素删除可以通过 del dict["key1"]；字典的清空可以通过 dict.clear() -> {}仍是字典

0、keys( )返回一个无序的、包含所有键的链表；values( )返回一个有序的、包含所有值的链表；

   items( )返回一个由 tuple(key，value) 组成的链表；
***

##链表 <--> 字符串

： str = "_".join（str_list），把str_list 内的每个元素都用‘_’ 连接成一个字符串

：list = str.split（"_"），在str 中每遇到一个 ‘_’ 就切开，并将分离的字符串作为链表的一个元素

##Python 字符串
：这里没有像C里的字符类型，单个字符仅仅是长度为一的字符串

：python 字符串不能被改写，按下标或切片赋值均会失败

：单引号' '和双引号" "字符串是完全相同的，它们没有在任何方面有区别

：在单引号字符串中可直接使用双、三引号，在双引号字符串中可直接使用单引号，在三引号中可自由使用单、双引号

：在单，双引号字符串中使用同类引号，可以通过转义字符 \ 实现

：三引号""" """中的字符串被解释器打印出来的结果与它们输入的形式完全相同：内部的引号，用反斜杠标识的引号和各种怪字符，
都精确的显示出来。 

：自然字符串通过在字符串前加 r 或 R 来指定；unicode 字符串通过在字符串前加 u 或 U 来指定

：字符串可以用+号联接，也可以用*号循环，但e = 'ab' 'cd'这种方式只对字符串值有效
***

##Python 之链表：有序集合
创建    ：list = [1，2，"a"，"b"，"mac"]

元素索引：list [4] -> 'mac' 或 list [ -1] -> 'mac' ，负索引公式 list [ -n ] = list [ len(list) - n ]

切片索引：list [1：3] -> [ 2，'a' ，'b' ] 或 list [-4：3] -> [ 2，'a' ，'b' ] 

快捷切片：list [：n] -> 从开始到 list[ n-1]；list [n：] -> 从 list[ n ] 个开始到结束

修改    ：list [n] = 0；list [ m：n ] ＝ [1，2.....]

添加    ：不能像字典那样直接添加，因为链表是有序排列，需要位置信息，list.append( )，list.insert( )，list.extend( [ ] )  

搜索下标：list.index（"mac"） -> 4，它只返回要搜索的元素在链表中第一次出现的位置

删除    ：list.remove(element)，它只删除第一个 element 的存在，不止一个存在的话就需要多次执行

0、链表可以包含任何数据类型！

1、测试某个元素是否在 list 中，用 in，如 ”mac" in list，根据结果它会返回 True 或 False

2、insert（） 的参数可以是单个元素，也可以是一个 list，当是一个list 的时候，父 list 的长度只加1

3、extend （）的参数只能是一个 list，加上去之后父 list 的长度是随着子 list 的长度而相应增长的

4、pop（）做两件事，删除最后一个元素的同时返回该元素

5、list = list + otherlist 得到的结果与 list.extend(otherlist) 同，但是＋形成一个新的链表，而 extend 只是在原来的
链表上动态增长，所以 extend 的速度更快，特别是对于大的链表

6、list += otherlist 与 extend 同等

7、用于链表的 * 操作符是个起到重复的功能

8、链表的映射是将一个序列(list,tuple,dict)映射为另一个 list，所以整个表达式要用[]包含，比如 listb = [a*2 for a in lista]
***
##下标索引※切片索引
：链表、tuple 和字符串都是序列，是序列就支持下标和切片索引

：字符串可以用下标查询，但如果超过了索引范围，就会出错

：切片操作符 s[a:b]，a是闭环，b是开环，即返回的结果包含a，但不包含b

：要想包含最好一个元素，则冒号:后空着，不要指定b

：如果不指定第一个数，就从序列首开始。如果没有指定第二个数，则Python会停止在序列尾。

：返回的序列从开始位置开始，刚好在结束位置之前结束。即开始位置是包含在切片中的，而结束位置被排斥在切片外

：四种情况下，切片索引将返回空字符串（假设 a = "lucky"）

1，下界超出上界，如 a[3：1] 或 a[－1：－3]，但有种情况例外，如 a[1：－1]

2，上界等于下界，如 a[0:0] 或 a[－1：－1]

3，上下界均右溢，如 a[10：100]

4，上下界均左溢，如 a[－100：－10]
***
##Python 之Tuples】可以包含数字，字符串，链表，字典和另一个 tuple ！

：tuple 是不可变的list，一旦创建了一个 tuple，就不能以任何方式改变它

：tuple 没有方法，不能增加、删除或查找元素,只能使用in查看是个元素是否存在于tuple

：tuple 之内的 tuple 不会失去它的身份，它仍然是个 tuple

：空的 tuple 用一对空的圆括号表示；单个元素的 tuple 必须在元素后加个逗号，用来区别带圆括号的对象

：元组最通常的用法是用在打印语句中，如  print '%s is %d years old' % (name, age)

###相同点：
1、tuple 的创建和链表几乎一样，除了是使用圆括号而不是方括号，例如 tuple = （1，2，"a"，"b"）

2、tuple 也是有序排列的，第一个元素也是从下标 0 开始

3、和链表一样，负索引也是从最后一个元素倒着开始的

4、切片功能和链表也一样，只不过list 的切片得到的仍是list， tuple 切片得到的仍是 tuple

5、tuple 和 list 之间可以相互转化，通过内置函数 tuple() 和 list()

###不同点：
1、tuple 是 immutable 的，它不具有像list 的 append，extend，remove，pop，index 那些方法

2、然而，你可以像list 一样，使用 in 方法查看某个元素是否存在于 tuple 里面

3、tuple 可以被用作字典里的键，而list 却不可以，因为字典的键也是 immutable 的，两者是共同的

4、但是如果 tuple 里含有list，那该 tuple 就会被当作 mutable

何时选择 tuple：
访问 tuple 比 访问 list 更快，当你需要一个集合的同时又不需要去改变什么的时候
***

##Python 类与面向对象
1、和C＋＋不同，Python 类的所有函数在定义的时候必须显式给定一个形参，等价于 this，但在调用时却不必为它赋值

a、当你定义你自己的类方法时，必须明确将self作为每个方法的第一个参数列出，包括__init__()

b、当从你的类中调用一个父类的一个方法时，你必须包括self参数

c、当你从类的外部调用你的类方法时，不必对self指定任何实参，python会自动替你增加实例的引用

2、Python 类的构造函数是  __init__（），同样需要指定第一个参数 self，以后每次创建对象时，便自动初始化

3、Python 类的析构函数是  __del__（），当对象销毁的时候自动调用，如del a 或者a 不再代表这个对象

4、Python 类中的变量也称为域，类域相当于静态变量，在类定义之后定义，对象域相当于实例变量，在__init__中定义

5、类的变量由该类所有的对象共享，当某个对象对类的变量做了改动，就会反映到所有其他的对象上

6、对象的变量由某个对象私有，在同一个类的不同实例中，虽然对象的变量有相同的名称，但是它们却互不相关

7、类的实例化MyObject＝MyClass() － MyObject.method(a，b) － MyClass.method(MyObject，a，b)

8、Python不会自动调用基本类的constructor，你得亲自在定义子类的时候调用它

8、继承优点一：代码重用，不必重写父类的代码，也不必创建新类

9、继承优点二：对父类的修改可以自动反映到所有的子类

0、继承优点三：对子类的修改不会影响父类和其它的子类

0、继承优点四：子类的对象可以被当作父类的对象来使用，称为多态

0、如果在继承元组中列了一个以上的类，那么它就被称作多重继承 
***

##Python 异常
try     ：我们把所有可能引发异常的语句放在try块中，对于每个try从句，至少都有一个相关联的except从句

except  ：一个预定义的异常或自定义的异常类名及对象，或者一组包括在圆括号内的异常，如果没有特别给出，只要出现异常，
它就会用后面的代码来处理

raise   ：预定义的异常或自定义的异常类型，即一个Error 或 Exception 类的子类

finally ：无论是否发生异常，finally 从句都会在程序退出之前被执行，如果你想在一个 try 块下同时使用 except 从句和 finally 从句的话，需要把一个嵌入另外一个
***
##Python 数据转换

tuple 和 list 之间可以相互转化，通过内置函数 tuple() 和 list()

string 和 list 之间可以相互转化，通过字符串函数join() 和 split()，但是 join 只能用于元素是字符串的list

***
#关键字：Python